# Восстановление после ошибок 

##### В ходе проекта: 

- изучены разные стратегии восстановления после ошибок (error recovery) во время синтаксического анализа,
- реализованы разные стратегии восстановления после ошибок,
- приведено множество примеров, демонстрирующих различия стратегий восстановления после ошибок, подчеркивающих их преимущества и недостатки.

## 1. Запуск 

##### Запуск стратегии  Phase Level Recovery

Парсер: `python ./parser_phase_level.py <путь для файла, который нужно проанализировать >  <путь до директории, в которую можно положить временный файл>` 

Все ошибки будут записаны в файл `file.out`, который будет создан рядом с анализируемым файлом

##### Запуск стратегии  Phase Level Recovery

Парсер: `python ./parser_panic_mode.py <путь для файла, который нужно проанализировать >  <путь до директории, в которую можно положить временный файл>` 

## 2. Задачи 

##### Елфимова Татьяна

- лексер и парсер для конктретного языка, написанные с помощью `ply.lex`  и `ply.yacc`
- реализация одной стратегии
- тесты
- сравнение двух реализаций

##### Мосин Александр

- исследование различных стратегий
- написание парсера для одной стратегии
- примеры
- сравнение двух реализаций

## 3. Синтаксис языка

Грамматики со следующими правилами:

- стартовый терминал отделяется `< >`
- нетерминалы `' '`
- терминалы `" "`
- пустая строка : `e`
- правило:
  - `нетерминал = (терминалы и нетерминалы) ,`  
  - каждое правило должно располгаться на одной строке
  - пустых строк быть не должно

Пример корректной грамматики:

```
<E> = e,
`E` = "["`E`"]",
`E` = `E``E`,
```

## 3. Описание выбранных стратегий

####  Phase Level Recovery

Использовалась стратегия Phase Level Recovery ([ссылка](https://www.geeksforgeeks.org/error-recovery-strategies-in-compiler-design/)). В этой стратегии происходит исправление ошибок по мере их нахождения: обрабатывается одна строчка, если в ней найдена какая-то ошибка, то происходит исправление этой ошибки, анализ не переходит на новую строку, пока текущая строка не будет полностью корректна (например, в примере, приведенном ниже, в первой строке сначала идет замена двух токенов на один нетерминал, а затем вставка запятой).

###### Пример работы:

###### Тест:

```
<E> `A` = e
`E` = "(" `E` ")"

`E` = e
`E` "a"
```

###### Вывод:

```
You should use one non_terminal before arrow :1
Expected `,` :1
Expected `,` :2
Expected rule :3
Expected `,` :4
Expected rule :5
```

##### Плюсы стратегии:

- можно легко применить к разным грамматикам
- есть возможность найти много разных ошибок в одной строке

##### Минусы стратегии:

- необходимость проанализировать и обработать каждую конкретную ошибку, а также продумать, как её исправить

  

##### Подробнее о других стратегиях в файле : [Исследование_различных_стратегий.pdf](https://github.com/tanya011/fl-2022-hse-win/blob/proj/%D0%98%D1%81%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%BD%D1%8B%D1%85_%D1%81%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D0%B9.pdf)

## 4. Сравнение двух стратегий

Рассмотрим, как работают стратегии на разных примерах:

#### Пример 1: Error - extra token

```
`E` = "(" ")" , "(" ")",
```

##### Output (Phase mode recovery):

```
You shouldn't use commas between tokens :1
```

###### Поснение:

Такая ошибка была предсказана и обработана.

##### Output (Panic mode recovery):

```
All characters after the ending character (,) have been deleted
```

###### Пояснение:

Как видно реализация Panic Mode просто выкинет все символы после ‘,’ - то есть *"(" ")".* А останется, следовательно

```
`E` = "(" ")" ,
```

`*"(" ")"*` является корректной строкой и выкидывать ее было не обязательно, достаточно просто удалить лишнюю запятую.

###### Вывод:  Phase mode recovery, на данном примере отработал лучше.

#### Пример 2: Error - not have END

```
`E` = "(" ")"
```

##### Output (Panic mode recovery):

```
You have to add an end of line character (,)
```

##### Output (Phase mode recovery):

```
Expected `,` :1
```

###### Как видим, обе реализации говорят, что нужно добавить символ конца строки во входную строку. На данном примере стратегии отработают одинаково.

#### Пример 3: Error - not have non-terminal

```
“a” = “b”,
```

##### Output (Panic mode recovery):

```
This rule has been removed because it does not contain non-terminal characters
```

###### Пояснение:

Так как отсутствует нетерминальный символ в начале строки, то метод panic mode увидит ошибку в самом начале, следовательно удалит все смиволы после, следовательно удалит всю строчку целиком, то есть правило будет удалено.

##### Output (Phase mode recovery):

```
You should use one non_terminal before arrow :1
```

###### Получается на данном примере, стратегии также отработают одинаково.

#### Пример 4: 

```
`E` = "(" ")" ,,,,,,
```

##### Output (Panic mode recovery):

```
All characters after the first ending character (,) have been deleted
```

###### Пояснение:

Panic mode выкинет все символы после первой запятой, независимо от того, что следует далее

##### Output (Phase mode recovery):

```
Unexpected END(,) :1
```

###### Пояснение:

Парсер не ожидает получения такой строки, потому что соответсвующий случайн не обработан, мы сами не прописали, что делать в такой ситуации и как превратить такую строку в корректную, чтобы продолжить её обработку и поиск других ошибок. 

###### В данном примере можно сделать вывод, что Panic mode отработает лучше.



## 5. Заключение: 

##### Основные плюсы panic mode перед phase mode

- более простая реализация
- обрабатывает любую ошибку
- никогда не завершается с ошибкой

##### Основные плюсы phase mode перед panic mode

- может обработать более одной ошибки в одной строке
